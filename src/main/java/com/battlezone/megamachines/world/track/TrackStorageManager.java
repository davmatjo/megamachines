package com.battlezone.megamachines.world.track;

import com.battlezone.megamachines.renderer.ui.menu.TrackOption;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

public class TrackStorageManager {

    //File extension for tracks
    private final static String EXTENSION = ".track";

    /**
     * @return The folder in which user generated tracks are stored
     */
    private File getFolder() {
        File f = new File("user_tracks");
        f.mkdir();
        return f;
    }

    /**
     * @return The path in which user generated tracks are stored
     */
    private Path getPath() {
        return getFolder().toPath();
    }

    /**
     * Generates a timestamp based filename to use for a new track
     *
     * @return File name, without extension
     */
    private String generateFileName() {
        var formatter = new SimpleDateFormat("dd.MM.yy-HH.mm");
        return formatter.format(new Date());
    }

    /**
     * Generates a path for a new file, generating a name using {@link #generateFileName}
     *
     * @return Full path
     */
    private Path getPathForNewFile() {
        File folder = getFolder();
        String folderPath = folder.getAbsolutePath();
        String fileName = generateFileName();
        String path = folderPath + File.separator + fileName + EXTENSION;
        return new File(path).toPath();
    }

    /**
     * Saves a track using an autogenerated name
     *
     * @param track The track to save
     */
    public void saveTrack(Track track) {
        byte[] bytes = track.toByteArray();
        Path path = getPathForNewFile();
        try {
            Files.write(path, bytes);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * Returns every {@link TrackOption} the user has saved
     *
     * @return
     */
    public List<TrackOption> getTrackOptions() {
        var tracks = new ArrayList<TrackOption>();

        Path rootPath = getPath();
        try {
            Files.list(rootPath).forEach(filePath -> {
                Track t = trackFromPath(filePath);
                if (t != null)
                    tracks.add(new TrackOption(getFileName(filePath), t));
            });
        } catch (IOException e) {
            e.printStackTrace();
        }

        return tracks;
    }

    /**
     * Returns the name of a file
     *
     * @param path
     * @return
     */
    private String getFileName(Path path) {
        String filename = path.getFileName().toString();
        if (filename.endsWith(EXTENSION)) {
            filename = filename.substring(0, filename.length() - EXTENSION.length());
        }
        return filename;
    }

    /**
     * Reads a {@link Track} in from a file
     *
     * @param path of the file
     * @return The track
     */
    private Track trackFromPath(Path path) {
        try {
            var bytes = Files.readAllBytes(path);
            return Track.fromByteArray(bytes, 0);
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }
    }

    /**
     * Rename a track file
     *
     * @param oldName The old name of the track. File extension should not be included
     * @param newName The new name of the track. File extension should not be included
     */
    public void rename(String oldName, String newName) {
        var oldPath = getFolder().getAbsolutePath() + File.separator + oldName + EXTENSION;
        var newPath = getFolder().getAbsolutePath() + File.separator + newName + EXTENSION;

        var oldFile = new File(oldPath);
        var newFile = new File(newPath);
        oldFile.renameTo(newFile);
    }
}
